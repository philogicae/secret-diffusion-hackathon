Secret:
1. Simple: Msg + auto prompt v2.1 + extra
2. Prompt: No msg + custom prompt + extra (ex: custom model)
3. Complete: Msg + custom prompt + extra

Image & Encryption:
- Generate sbt keypair on back
- Create image and add image hash to secret
- Encrypt secret with sbt-pk
- Push image and secret on IPFS
- Mint SBT

Contract:
- 1 original SBT (owner) + n fixed mintable NFTs
- Metadata=
• Id: Serial number (at mint)
• Name: Secret nickname
• Desc: Type of secret (1/2/3)
• URL secret
• URL img (no metadata)
• metahash of metadata (at mint)-> indexed with sbt-pk
- NFTdata=
• Id: Serial number (sbt:0, nft from 1)
• State: sealed / revealed (0/1)
Combined ids (for URI) = see hash

Proof of ownership:
- Wallet signer (pk)-> in owners list-> open button if sealed

Open:
- If owner, commit tx.
- Event on page, get encrypted secret, decrypt with sbt-pk,
- encrypt with pa, send to front, reveal on sign-proof with pk.

Proof of knowledge:
- Check owners list-> [index, state]
if owner not -1 & state not 0: true

Verify authenticity:
- Metahash-> sbt-pk-> decrypt secret-> check image hashs

Front: single page with web3 auth
- Create Secret
- Transfer / Sell
- View & Verify

Back: flask with web3js lib on html
- Prompt crafter
- Image selector
- 1 pk generated by SBT, linked to metahash
- Link SD API with any source url (field at the top)

TODO:
- sbt-pk storage
- Erc standard: semi fungible erc1155
